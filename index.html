<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>–ü–∏—Ü—Ü–∞ –∫—Ä—É—Ç–∏—Ç—Å—è ‚Äî –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∞</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #0d0805;
      color: #f5e6d3;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px;
      touch-action: manipulation;
    }
    h1 {
      font-size: 1.25rem;
      margin: 0 0 8px;
      font-weight: 600;
    }
    .timer {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 12px;
      color: #ffb347;
    }
    .timer.warning { color: #ff6b6b; }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      max-width: 320px;
      margin-bottom: 12px;
    }
    .pizza-wrap {
      position: relative;
      aspect-ratio: 1;
      max-width: 150px;
      margin: 0 auto;
    }
    .pizza-wrap canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid rgba(255,179,71,0.5);
      cursor: pointer;
      touch-action: manipulation;
    }
    .pizza-wrap.locked canvas {
      border-color: #ffb347;
      box-shadow: 0 0 12px rgba(255,179,71,0.6);
    }
    .pizza-wrap.locked::after {
      content: 'üîí';
      position: absolute;
      top: 4px;
      right: 4px;
      font-size: 14px;
    }
    .buttons {
      display: flex;
      gap: 20px;
      margin-top: 0;
      padding: 8px 0 16px;
      max-width: 320px;
      width: 100%;
    }
    .btn {
      flex: 1;
      padding: 22px 16px;
      font-size: 1.75rem;
      font-weight: 600;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.2s;
      touch-action: manipulation;
    }
    .btn:active { transform: scale(0.97); }
    .btn-rotate-cw {
      background: linear-gradient(180deg, #ff9a56 0%, #e85d04 100%);
      color: #fff;
      box-shadow: 0 4px 0 #c44a03;
    }
    .btn-rotate-ccw {
      background: linear-gradient(180deg, #5c7cfa 0%, #364fc7 100%);
      color: #fff;
      box-shadow: 0 4px 0 #2c3d99;
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    .hint {
      font-size: 0.8rem;
      color: rgba(245,230,211,0.6);
      margin-top: 8px;
      text-align: center;
      max-width: 320px;
    }
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 20px;
    }
    .modal.visible { display: flex; }
    .modal-content {
      background: #0d0805;
      border: 2px solid #ffb347;
      border-radius: 16px;
      padding: 24px;
      text-align: center;
      max-width: 320px;
    }
    .modal h2 { margin: 0 0 12px; font-size: 1.5rem; }
    .modal .score { font-size: 2rem; color: #ffb347; font-weight: 700; margin: 8px 0; }
    .modal button {
      margin-top: 16px;
      padding: 12px 32px;
      font-size: 1rem;
      font-weight: 600;
      background: #e85d04;
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    .header-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      position: relative;
      width: 100%;
      max-width: 320px;
    }
    .header-row h1 { margin: 0; }
    .btn-info {
      position: absolute;
      right: 0;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid rgba(255,179,71,0.6);
      background: transparent;
      color: #f5e6d3;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .btn-info.visible { display: flex; }
    .onboarding {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.92);
      z-index: 20;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      cursor: pointer;
    }
    .onboarding.visible { display: flex; }
    .onboarding-slide {
      display: none;
      text-align: center;
      font-size: 1.35rem;
      line-height: 1.4;
      max-width: 320px;
    }
    .onboarding-slide.active { display: block; }
    .onboarding-dots {
      position: absolute;
      bottom: 32px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 8px;
    }
    .onboarding-dots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
    }
    .onboarding-dots span.active { background: #ffb347; }
    .pizza-wrap.swap-flash {
      animation: swapFlash 0.4s ease-out;
    }
    @keyframes swapFlash {
      0% { filter: brightness(1.5); }
      50% { filter: brightness(1.9); }
      100% { filter: brightness(1); }
    }
    .pizza-wrap .pad {
      position: absolute;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      background: rgba(255, 200, 100, 0.22);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 0;
      pointer-events: none;
    }
    .pizza-wrap .pad .arr {
      font-size: 1.1rem;
      color: rgba(255, 230, 180, 0.9);
    }
    .pizza-wrap .pad.top { top: -18px; left: 50%; transform: translateX(-50%); }
    .pizza-wrap .pad.right { right: -18px; top: 50%; transform: translateY(-50%); }
    .pizza-wrap .pad.bottom { bottom: -18px; left: 50%; transform: translateX(-50%); }
    .pizza-wrap .pad.left { left: -18px; top: 50%; transform: translateY(-50%); }
    .pizza-wrap canvas { position: relative; z-index: 1; }
    .pizza-wrap .pad.right .arr { animation: arrowFloatR 1.2s ease-in-out infinite; }
    .pizza-wrap .pad.left .arr { animation: arrowFloatL 1.2s ease-in-out infinite; }
    .pizza-wrap .pad.top .arr { animation: arrowFloatT 1.2s ease-in-out infinite; }
    .pizza-wrap .pad.bottom .arr { animation: arrowFloatB 1.2s ease-in-out infinite; }
    @keyframes arrowFloatR { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(3px); } }
    @keyframes arrowFloatL { 0%, 100% { transform: rotate(180deg) translateX(0); } 50% { transform: rotate(180deg) translateX(-3px); } }
    @keyframes arrowFloatT { 0%, 100% { transform: rotate(-90deg) translateY(0); } 50% { transform: rotate(-90deg) translateY(-3px); } }
    @keyframes arrowFloatB { 0%, 100% { transform: rotate(90deg) translateY(0); } 50% { transform: rotate(90deg) translateY(3px); } }
  </style>
</head>
<body>
  <div class="header-row">
    <h1>–ü–∏—Ü—Ü–∞ –∫—Ä—É—Ç–∏—Ç—Å—è</h1>
    <button type="button" class="btn-info" id="btnInfo" title="–ü–æ–º–æ—â—å">i</button>
  </div>
  <div class="timer" id="timer">100</div>
  <div class="grid" id="grid"></div>
  <div class="buttons">
    <button type="button" class="btn btn-rotate-ccw" id="rotateCCW">‚Ü∫</button>
    <button type="button" class="btn btn-rotate-cw" id="rotateCW">‚Üª</button>
  </div>
  <p class="hint">–¢–∞–ø –ø–æ —Ü–µ–Ω—Ç—Ä—É –ø–∏—Ü—Ü—ã ‚Äî –∑–∞–∫—Ä–µ–ø–∏—Ç—å/–æ—Ç–∫—Ä–µ–ø–∏—Ç—å. –¢–∞–ø –ø–æ –∫—Ä–∞–π–Ω–µ–º—É –∫—É—Å–æ—á–∫—É (–∫ —Å–æ—Å–µ–¥—É) ‚Äî –æ–±–º–µ–Ω —Å —Å–æ—Å–µ–¥–Ω–µ–π –ø–∏—Ü—Ü–µ–π.</p>

  <div class="modal" id="modal">
    <div class="modal-content">
      <h2 id="modalTitle">–ü–æ–±–µ–¥–∞!</h2>
      <p>–û—Å—Ç–∞–≤—à–∏–µ—Å—è —Ö–æ–¥—ã:</p>
      <div class="score" id="finalScore">0</div>
      <button type="button" id="modalBtn">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>
  </div>

  <div class="onboarding" id="onboarding">
    <div class="onboarding-slide active" data-slide="0">–°–æ–±–µ—Ä–∏ –ø–∏—Ü—Ü—ã —Å–Ω–æ–≤–∞</div>
    <div class="onboarding-slide" data-slide="1">–ú–µ–Ω—è–π –º–µ—Å—Ç–∞–º–∏ —Å–æ—Å–µ–¥–Ω–∏–µ –∫—É—Å–æ—á–∫–∏ —Ä–∞–∑–Ω—ã—Ö –ø–∏—Ü—Ü</div>
    <div class="onboarding-slide" data-slide="2">–í—Ä–∞—â–∞–π –≤—Å–µ –ø–∏—Ü—Ü—ã —Ä–∞–∑–æ–º, —á—Ç–æ–±—ã –ø–æ–º–µ–Ω—è—Ç—å</div>
    <div class="onboarding-slide" data-slide="3">–¢–∞–ø–Ω–∏ –Ω–∞ –ø–∏—Ü—Ü—É, —á—Ç–æ–±—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –µ—ë –≤—Ä–∞—â–µ–Ω–∏–µ –∏–ª–∏ —Ç–∞–ø–Ω–∏ —Å–Ω–æ–≤–∞ —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å –±–ª–æ–∫</div>
    <div class="onboarding-dots" id="onboardingDots">
      <span class="active"></span><span></span><span></span><span></span>
    </div>
  </div>

  <script>
    (function () {
      const PIZZA_NAMES = ['–∞—Ä—Ä–∏–≤–∞.avif', '–î–æ–¥–æ.avif', '–º–∞—Å–∞–ª–∞.avif', '–ø–µ–ø–ø–µ—Ä–æ–Ω–∏ —Ñ—Ä–µ—à.avif'];
      const PIZZAS = 4;
      const SECTORS = 8;
      const MAX_MOVES = 100;
      // –°–µ—Ç–∫–∞ 2√ó2: 0 1 / 2 3. –ö—Ä–∞—è —Å–≤—ë—Ä–Ω—É—Ç—ã.
      const NEIGHBOR_RIGHT = [1, 0, 3, 2];
      const NEIGHBOR_BOTTOM = [2, 3, 0, 1];
      const NEIGHBOR_LEFT = [1, 0, 3, 2];
      const NEIGHBOR_TOP = [2, 3, 0, 1];
      const VISUAL_TOP = 0, VISUAL_RIGHT = 2, VISUAL_BOTTOM = 4, VISUAL_LEFT = 6;
      const ANGLE_OFFSET = 180 / SECTORS;

      let images = [];
      let grid = [];   // grid[cellIndex][slotIndex] = { pizzaId, sectorIndex }
      let rotation = []; // rotation[cellIndex] = 0..5
      let locked = [];   // locked[cellIndex] = bool
      let lockedIndex = -1;
      let moves = MAX_MOVES;
      let gameOver = false;

      const gridEl = document.getElementById('grid');
      const timerEl = document.getElementById('timer');
      const modalEl = document.getElementById('modal');
      const modalTitle = document.getElementById('modalTitle');
      const finalScoreEl = document.getElementById('finalScore');
      const modalBtn = document.getElementById('modalBtn');
      const onboardingEl = document.getElementById('onboarding');
      const onboardingDotsEl = document.getElementById('onboardingDots');
      const btnInfo = document.getElementById('btnInfo');

      function loadImages() {
        return Promise.all(PIZZA_NAMES.map((name, i) => {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => { images[i] = img; resolve(); };
            img.onerror = () => reject(new Error('Failed to load ' + name));
            img.src = name;
          });
        }));
      }

      function shuffleSectors() {
        const pairs = [];
        for (let p = 0; p < PIZZAS; p++)
          for (let s = 0; s < SECTORS; s++)
            pairs.push({ pizzaId: p, sectorIndex: s });
        for (let i = pairs.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
        }
        for (let c = 0; c < PIZZAS; c++) {
          grid[c] = [];
          for (let s = 0; s < SECTORS; s++)
            grid[c][s] = { ...pairs[c * SECTORS + s] };
        }
        rotation = [0,0,0,0];
        locked = [false,false,false,false];
        lockedIndex = -1;
        moves = MAX_MOVES;
        gameOver = false;
      }

      function getDisplaySlot(cellIndex, slotIndex) {
        const r = rotation[cellIndex];
        const idx = (slotIndex - r + SECTORS) % SECTORS;
        return grid[cellIndex][idx];
      }

      function drawPizza(ctx, cellIndex, size) {
        const cx = size / 2, cy = size / 2;
        const radius = Math.min(cx, cy) - 2;
        for (let s = 0; s < SECTORS; s++) {
          const data = getDisplaySlot(cellIndex, s);
          const img = images[data.pizzaId];
          if (!img) continue;
          const startAngle = (s * 360 / SECTORS - 90 - ANGLE_OFFSET) * Math.PI / 180;
          const endAngle = ((s + 1) * 360 / SECTORS - 90 - ANGLE_OFFSET) * Math.PI / 180;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.arc(cx, cy, radius, startAngle, endAngle);
          ctx.closePath();
          ctx.clip();
          const sectorStart = (data.sectorIndex * 360 / SECTORS) * Math.PI / 180;
          ctx.translate(cx, cy);
          ctx.rotate(startAngle - sectorStart);
          const scale = (radius * 2.2) / Math.min(img.width, img.height);
          ctx.drawImage(img, -img.width * scale / 2, -img.height * scale / 2, img.width * scale, img.height * scale);
          ctx.restore();
        }
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1.2;
        for (let s = 0; s <= SECTORS; s++) {
          const a = (s * 360 / SECTORS - 90 - ANGLE_OFFSET) * Math.PI / 180;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(cx + radius * Math.cos(a), cy + radius * Math.sin(a));
          ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function createCanvases() {
        gridEl.innerHTML = '';
        const size = Math.min(150, Math.floor((window.innerWidth - 48) / 2 - 30));
        for (let i = 0; i < PIZZAS; i++) {
          const wrap = document.createElement('div');
          wrap.className = 'pizza-wrap' + (locked[i] ? ' locked' : '');
          wrap.dataset.cell = i;
          ['top', 'right', 'bottom', 'left'].forEach(function (dir) {
            const pad = document.createElement('div');
            pad.className = 'pad ' + dir;
            pad.innerHTML = '<span class="arr">‚Üí</span>';
            wrap.appendChild(pad);
          });
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          canvas.dataset.cell = i;
          wrap.appendChild(canvas);
          gridEl.appendChild(wrap);

          (function (cellIndex) {
            function getCoords(e) {
              const rect = canvas.getBoundingClientRect();
              const scaleX = canvas.width / rect.width;
              const scaleY = canvas.height / rect.height;
              let clientX, clientY;
              if (e.touches && e.touches.length) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
              } else if (e.changedTouches && e.changedTouches.length) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
              } else {
                clientX = e.clientX;
                clientY = e.clientY;
              }
              return {
                x: (clientX - rect.left) * scaleX - canvas.width / 2,
                y: (clientY - rect.top) * scaleY - canvas.height / 2
              };
            }
            function handleTap(e) {
              if (gameOver) return;
              const coords = getCoords(e);
              const x = coords.x, y = coords.y;
              const r = Math.hypot(x, y);
              const radius = Math.min(canvas.width, canvas.height) / 2 - 2;
              if (r < radius * 0.35) {
                if (lockedIndex === cellIndex) {
                  lockedIndex = -1;
                  locked[cellIndex] = false;
                } else {
                  if (lockedIndex >= 0) locked[lockedIndex] = false;
                  lockedIndex = cellIndex;
                  locked[cellIndex] = true;
                }
                updateUI();
                redrawAll();
                return;
              }
              const angle = Math.atan2(y, x);
              const angleDeg = (angle * 180 / Math.PI + 90 + ANGLE_OFFSET + 360) % 360;
              let sector = Math.floor(angleDeg / (360 / SECTORS)) % SECTORS;
              if (sector >= SECTORS) sector = 0;

              let neighbor = -1;
              let mySlot, otherSlot;
              if (sector === VISUAL_RIGHT && (neighbor = NEIGHBOR_RIGHT[cellIndex]) >= 0) {
                mySlot = (VISUAL_RIGHT - rotation[cellIndex] + SECTORS) % SECTORS;
                otherSlot = (VISUAL_LEFT - rotation[neighbor] + SECTORS) % SECTORS;
              } else if (sector === VISUAL_LEFT && (neighbor = NEIGHBOR_LEFT[cellIndex]) >= 0) {
                mySlot = (VISUAL_LEFT - rotation[cellIndex] + SECTORS) % SECTORS;
                otherSlot = (VISUAL_RIGHT - rotation[neighbor] + SECTORS) % SECTORS;
              } else if (sector === VISUAL_BOTTOM && (neighbor = NEIGHBOR_BOTTOM[cellIndex]) >= 0) {
                mySlot = (VISUAL_BOTTOM - rotation[cellIndex] + SECTORS) % SECTORS;
                otherSlot = (VISUAL_TOP - rotation[neighbor] + SECTORS) % SECTORS;
              } else if (sector === VISUAL_TOP && (neighbor = NEIGHBOR_TOP[cellIndex]) >= 0) {
                mySlot = (VISUAL_TOP - rotation[cellIndex] + SECTORS) % SECTORS;
                otherSlot = (VISUAL_BOTTOM - rotation[neighbor] + SECTORS) % SECTORS;
              }
              if (neighbor >= 0) {
                const a = grid[cellIndex][mySlot];
                const b = grid[neighbor][otherSlot];
                grid[cellIndex][mySlot] = { ...b };
                grid[neighbor][otherSlot] = { ...a };
                useMove();
                playSwapAnimation(cellIndex, neighbor);
                if (checkWin()) endGame(true);
              }
              updateUI();
              redrawAll();
            }
            canvas.addEventListener('click', function (e) {
              if (e.pointerType === 'touch') return;
              handleTap(e);
            });
            canvas.addEventListener('touchend', function (e) {
              if (!e.changedTouches || !e.changedTouches.length) return;
              e.preventDefault();
              handleTap(e);
            }, { passive: false });
          })(i);
        }
        redrawAll();
      }

      function playSwapAnimation(cellA, cellB) {
        const wraps = gridEl.querySelectorAll('.pizza-wrap');
        if (wraps[cellA]) wraps[cellA].classList.add('swap-flash');
        if (wraps[cellB]) wraps[cellB].classList.add('swap-flash');
        setTimeout(function () {
          wraps[cellA] && wraps[cellA].classList.remove('swap-flash');
          wraps[cellB] && wraps[cellB].classList.remove('swap-flash');
        }, 400);
      }

      function redrawAll() {
        const size = Math.min(150, Math.floor((window.innerWidth - 48) / 2 - 30));
        gridEl.querySelectorAll('.pizza-wrap canvas').forEach((canvas, i) => {
          const ctx = canvas.getContext('2d');
          canvas.width = size;
          canvas.height = size;
          drawPizza(ctx, i, size);
        });
        gridEl.querySelectorAll('.pizza-wrap').forEach((wrap, i) => {
          wrap.className = 'pizza-wrap' + (locked[i] ? ' locked' : '');
        });
      }

      function updateUI() {
        timerEl.textContent = moves;
        timerEl.classList.toggle('warning', moves <= 20);
        document.getElementById('rotateCW').disabled = gameOver || moves <= 0;
        document.getElementById('rotateCCW').disabled = gameOver || moves <= 0;
      }

      function useMove() {
        moves--;
        updateUI();
        if (moves <= 0 && !checkWin()) endGame(false);
      }

      function rotateAll(clockwise) {
        if (gameOver || moves <= 0) return;
        const delta = clockwise ? 1 : -1;
        for (let i = 0; i < PIZZAS; i++) {
          if (!locked[i]) rotation[i] = (rotation[i] + delta + SECTORS) % SECTORS;
        }
        useMove();
        if (checkWin()) endGame(true);
        redrawAll();
      }

      function checkWin() {
        for (let c = 0; c < PIZZAS; c++) {
          const base = getDisplaySlot(c, 0).pizzaId;
          for (let s = 0; s < SECTORS; s++) {
            const d = getDisplaySlot(c, s);
            if (d.pizzaId !== base || d.sectorIndex !== s) return false;
          }
        }
        return true;
      }

      function endGame(won) {
        gameOver = true;
        modalTitle.textContent = won ? '–ü–æ–±–µ–¥–∞!' : '–•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å';
        finalScoreEl.textContent = moves;
        modalEl.classList.add('visible');
      }

      modalBtn.addEventListener('click', function () {
        modalEl.classList.remove('visible');
        shuffleSectors();
        createCanvases();
        updateUI();
      });

      document.getElementById('rotateCW').addEventListener('click', function () { rotateAll(true); });
      document.getElementById('rotateCCW').addEventListener('click', function () { rotateAll(false); });

      function setOnboardingSlide(index) {
        onboardingEl.querySelectorAll('.onboarding-slide').forEach(function (el, i) {
          el.classList.toggle('active', i === index);
        });
        onboardingDotsEl.querySelectorAll('span').forEach(function (dot, i) {
          dot.classList.toggle('active', i === index);
        });
      }

      function showOnboarding(fromInfo) {
        setOnboardingSlide(0);
        onboardingEl.classList.add('visible');
        onboardingEl.dataset.fromInfo = fromInfo ? '1' : '0';
      }

      function closeOnboardingAndMaybeStart() {
        onboardingEl.classList.remove('visible');
        var fromInfo = onboardingEl.dataset.fromInfo === '1';
        if (!fromInfo) startGame();
      }

      function startGame() {
        btnInfo.classList.add('visible');
        loadImages().then(function () {
          shuffleSectors();
          createCanvases();
          updateUI();
          }).catch(function (err) {
          timerEl.textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + err.message;
        });
      }

      onboardingEl.addEventListener('click', function () {
        var active = onboardingEl.querySelector('.onboarding-slide.active');
        var idx = active ? parseInt(active.dataset.slide, 10) : 0;
        if (idx < 3) {
          setOnboardingSlide(idx + 1);
        } else {
          closeOnboardingAndMaybeStart();
        }
      });

      btnInfo.addEventListener('click', function () { showOnboarding(true); });

      showOnboarding(false);
    })();
  </script>
</body>
</html>
